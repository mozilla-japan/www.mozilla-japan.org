<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=euc-jp">
<meta http-equiv="imagetoolbar" content="no" />
<meta name="robots" content="noodp,noydir" />
<link rel="home" href="http://mozilla.jp/" title="Home" />
<link rel="alternate" type="application/rss+xml" title="Mozilla Japan ブログ (RSS)" href="http://mozilla.jp/blog/feed/" />
<link rel="alternate" type="application/rss+xml" title="Mozilla Japan プレスリリース (RSS)" href="http://mozilla.jp/press/feed/" />
<link rel="alternate" type="application/rss+xml" title="Mozilla Foundation 最新情報 (RSS)" href="/news.rdf">
<link rel="stylesheet" type="text/css" href="/css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="/css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="/css/cavendish/content.css" title="Cavendish" media="all">
<link rel="stylesheet" type="text/css" href="/css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="/css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="/images/mozilla-16.png" type="image/png">


   <meta name="GENERATOR" content="Mozilla/4.76 [en] (WinNT; U) [Netscape]">
   <title>Charset Detector Interface</title>

<style type="text/css" media="screen,tv">
.em {
	text-align: center;
	font-size: 200%;
}
.text {
	margin-left: 2em;
	margin-right: 2em;
	text-align: center;
}
.jtp {
	margin-right: 2em;
	text-align: right;
	font-size: 80%;
}
</style>

<link rel="alternate" hreflang="en" modified="November 20, 2002">


</head>

<body id="www-mozilla-japan-org" class="deepLevel">
<div id="container">
<p class="important">現在、当サイト「mozilla.org 日本語版」の和訳文書は更新されておらず、<a href="http://www.mozilla.org/projects/intl/ChardetInterface.htm">mozilla.org の原文</a> よりも内容が古くなっている可能性があります。ご不便をお掛けしますが、最新の情報は原文をご確認ください。</p>

<p class="skipLink"><a href="#mainContent" accesskey="2">メインコンテンツへスキップ</a></p>
<div id="header">
<h1><a href="http://mozilla.jp/" title="Mozilla Japan ホームページへ戻る" accesskey="1">Mozilla Japan</a></h1>
<ul>
<li id="menu_aboutus"><a href="http://mozilla.jp/about/" title="Mozilla Japan について">組織概要</a></li>
<li id="menu_developers"><a href="/developer/index.html" title="Mozilla 製品をあなたのアプリケーションにも">開発情報</a></li>
<li id="menu_support"><a href="http://mozilla.jp/support/" title="個人および法人向けのサービス・サポート">サポート</a></li>
<li id="menu_products"><a href="http://mozilla.jp/products/" title="Mozilla 製品概要">製品情報</a></li>
</ul>
<form action="http://www.google.com/cse">
  <div id="lang_form">
    <input type="hidden" name="cx" value="004119830362093040131:jpn2pz-pybe" />
    <input type="hidden" name="cof" value="FORID:0" />
    <input type="hidden" name="ie" value="EUC-JP" />
    <input type="hidden" name="oe" value="UTF-8" />
    <label>サイト内検索: <input type="text" name="q" size="30" /></label>
    <input type="submit" name="sa" value="検索" />
  </div>
</form>

</div>

<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="ロードマップ"  href="../../roadmap.html"><strong>ロードマップ</strong></a></li>
<li><a title="プロジェクト"  href="../../projects/"><strong>プロジェクト</strong></a></li>
<li><a title="開発者向け"  href="../../developer/index.html"><strong>コーディング</strong></a>
<ul>
<li><a title="モジュールオーナー"  href="../../owners.html">モジュールオーナー</a></li>
<li><a title="ハック"  href="../../hacking/">ハック</a></li>
<li><a title="ソースの入手"  href="http://developer.mozilla.org/ja/Download_Mozilla_Source_Code">ソースの入手</a></li>
<li><a title="Mozilla のビルド"  href="http://developer.mozilla.org/ja/Build_Documentation">ビルド</a></li>
</ul>
</li>
<li><a title="テスト"  href="http://quality.mozilla.org/"><strong>テスト</strong></a>
<ul>
<li><a title="リリース"  href="../../download.html">リリース</a></li>
<li><a title="テスター向け最新ビルド"  href="../../developer/index.html">ナイトリービルド</a></li>
<li><a title="テスター向けバグ報告窓口"  href="https://bugzilla.mozilla.org/">問題の報告</a></li>
</ul>
</li>
<li><a title="Mozilla 開発者向けツール"  href="http://developer.mozilla.org/ja/Mozilla_Development_Tools"><strong>ツール</strong></a>
<ul>
<li><a title="テスター向けバグ追跡システム"  href="https://bugzilla.mozilla.org/">Bugzilla</a></li>
<li><a title="Mozilla ビルドの最新状況"  href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox">Tinderbox</a></li>
<li><a title="最新のチェックイン"  href="http://bonsai.mozilla.org/cvsqueryform.cgi">Bonsai</a></li>
<li><a title="ソースコードクロスリファレンス"  href="http://mxr.mozilla.org/">MXR</a></li>
</ul>
</li>
<li><a title="よくある質問"  href="../../faq.html"><strong>FAQ</strong></a></li></ul>

<ul id="nav">
<li><a title="Mozilla Developer Center 日本語版：最新開発情報用 wiki"  href="http://developer.mozilla.org/ja/"><strong>MDC 日本語版</strong></a></li></ul>

</div>
<hr class="hide">
<div id="mainContent">







<div style="border: 2px solid #444444; margin: 2em; background-color: #F5FAFF;">

  <p class="em">本文書は鋭意翻訳中です。</p>
  <!--p class="text">現在 <a href="http://kawaguchiyohkan.tripod.co.jp/GeckoEmbeddingBasics/EmbeddingBasics.html">草稿</a> が発表されています。<br>
  コメントはもじら組和訳プロジェクト <a href="http://moz.skillup.jp/jtp/"> 連絡用掲示板 </a> の <a href="http://moz.skillup.jp/jtp/viewtopic.php?t=299">該当スレッド</a> にお願いします。</p-->
  <p class="text">原文 &quot;<a href="http://www.mozilla.org/projects/intl/ChardetInterface.htm">Charset Detector Interface</a>&quot; は <a href="http://www.mozilla.org/">mozilla.org</a> をご覧ください。</p>

  <p class="jtp"><a href="http://www.mozilla-japan.org/">Mozilla Japan</a> <a href="http://www.mozilla-japan.org/jp/td/">翻訳部門</a></p>
</div>


<font face="Arial">Charset Detector Interface</font>
<p><font size=-1>This is the charset detectoryq interface that is exposed
to outside world, in our case, the browser. In the very beginning, caller
calls detectoryq "Init()" method and let detector know how it would like
to be notified about the detecting result. Observer pattern is used in
this case. Then the caller just need to feed charset detector with text
data through "DoIt()". This can be done through a series "DoIt()" calls,
with each call only contains part of the data. This can be very useful
if the data is only partially available at one time. In our case, since
the data comes from network, we can start detecting long before network
finishes transferring all data. When detector is confident enough about
one encoding, it will notify its caller and stop detecting. If all data
has been feed to detector but detector still is not confident enough about
any encoding, method "Done" will tell detector to make a best guess.</font>
<p><font face="Courier New"><font size=-1>class nsICharsetDetector : public
nsISupports {</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; public:</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; NS_DEFINE_STATIC_IID_ACCESSOR(NS_ICHARSETDETECTOR_IID)</font></font>
<p><font face="Courier New"><font size=-1>&nbsp; //Setup the observer so
it know how to notify the answer</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; NS_IMETHOD Init(nsICharsetDetectionObserver*
observer) = 0;</font></font>
<p><font face="Courier New"><font size=-1>&nbsp; //Feed a block of bytes
to the detector.</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; //It will call the Notify
function of the nsICharsetObserver if it</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; //find out the answer.</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; // aBytesArray - array
of bytes</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; // aLen - length of aBytesArray</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; // oDontFeedMe - return
PR_TRUE if the detector do not need the</font></font>
<br>&nbsp; <font face="Courier New"><font size=-1>// following block</font></font>
<br>&nbsp; <font face="Courier New"><font size=-1>// PR_FALSE it need more
bytes.</font></font>
<br>&nbsp; <font face="Courier New"><font size=-1>// This is used to enhance
performance</font></font>
<br>&nbsp; <font face="Courier New"><font size=-1>NS_IMETHOD DoIt(const
char* aBytesArray, PRUint32 aLen, PRBool* oDontFeedMe) = 0;</font></font>
<p>&nbsp; /<font face="Courier New"><font size=-1>/It also tell the detector
the last chance the make a decision</font></font>
<br>&nbsp; <font face="Courier New"><font size=-1>NS_IMETHOD Done() = 0;</font></font>
<br><font size=-1>}<font face="Courier New">;</font></font>
<br>&nbsp;
<br>&nbsp;
<p><font face="Arial">Inside Charset Detector</font>
<p><font size=-1>Inside Charset Detector, major work is done by function
"HandleData()". In fact, "DoIt" has very little extra thing to do other
than call "HandleData". The following is the algorithm logic using C-Like
Pseudo-Language. Some detail is drop in order to make main point more clear.</font>
<p><font face="Courier New"><font size=-1>HandleData(batch_of_text)</font></font>
<br><font face="Courier New"><font size=-1>{</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; if (batch_of_text contains
BOM)</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; report UCS2;</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; if ((inputState is PureAscii)
|| (inputState is EscAscii))</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; if (batch_of_text
contains 8-bits-byte)</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inputState = HighByte;</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; else if ((inputState
is PureAscii ) &amp;&amp; (batch_of_text contains Esc_Sequence) )</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inputState = EscAscii;</font></font>
<p><font face="Courier New"><font size=-1>&nbsp; if (inputState is HighByte)</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; {</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; Remove Ascii
character that is not neighboring to 8-bits byte</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; For each
prober in multibyte_probers</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; Prober.HandleData(batch_of_text);</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; For each
prober in singlebyte_probers</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; Prober.HandleData(batch_of_text);</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; }</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; else if (inputState is
EscAscii)</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; {</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; For each
prober in (ISO2022_XX or HZ)</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; Prober.HandleData(batch_of_text);</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; }</font></font>
<br><font face="Courier New"><font size=-1>}</font></font>
<p><i><font face="Courier New"><font size=-1>nsUniversalDetector.h</font></font></i>
<br><i><font face="Courier New"><font size=-1>nsUniversalDetector.cpp</font></font></i>
<p><i><font face="Courier New"><font size=-1>Implemented the high level
control logic.</font></font></i>
<br>&nbsp;
<br>&nbsp;
<p>Charset Prober
<p><font size=-1>A charset prober verifies if the input data is belong
to certain encoding or group of encoding. It maintains its state in member
"mState", which has 3 possible value. State "eDetecting" means it hasny
found any sure answer yet, "eFoundIt" and "eNotMe" carries the same meaning
as their names. Method "GetCharSetName" tell its caller its sure answer
or best guess.</font>
<p><font size=-1>Generally, for each encoding we implemented a charset
prober. Several probers can be wrapped together with a wrapper prober.
It is also possible for a prober to "probe" several encodings. Each charset
prober is designed, implemented and working independently. This enables
prober caller to eliminate certain probers when it has any pre-knowledge.
For example, if user know that an html page is some kind of Japanese encoding,
non-Japanese charset probers will not be fired. If user have not interest
in certain languages, they can also eliminate those charset probers. Those
measures will lead to a small footprint and faster performance.</font>
<p><font face="Courier New"><font size=-1>typedef enum {</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; eDetecting = 0,</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; eFoundIt = 1,</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; eNotMe = 2</font></font>
<br><font size=-1>}<font face="Courier New"> nsProbingState;</font></font>
<p><font face="Courier New"><font size=-1>class nsCharSetProber {</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; public:</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; nsCharSetProber(){};</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; virtual const
char* GetCharSetName() {return "";};</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; virtual nsProbingState
HandleData(const char* aBuf, PRUint32 aLen) = 0;</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; nsProbingState
GetState(void) {return mState;};</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; virtual void
Reset(void) {mState = eDetecting;};</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; virtual float
GetConfidence(void) = 0;</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; virtual void
SetOpion() {};</font></font>
<br><font face="Courier New"><font size=-1>&nbsp; protected:</font></font>
<br><font face="Courier New"><font size=-1>&nbsp;&nbsp;&nbsp; nsProbingState
mState;</font></font>
<br><font face="Courier New"><font size=-1>};</font></font>
<br>&nbsp;
<br>&nbsp;
<p><font face="Arial">How multi-byte encoding charset prober works</font>
<p><font size=-1>For charset prober verifying SJIS, EUC-JP, EUC-KR, EUC-CN
(or GB2312), EUC-TW, Big5 encodings, each prober embeds state machine (mCodingSM),
which identify legal byte sequence base on its encoding scheme. If an illegal
byte sequence is met, this state machine will reach "eError" state. That
signifies a failure for this prober, and prober will report negative answer
to its caller. Once state machine reach "eStart" state, it means sequence
of bytes has been identified as a character. This character will be sent
to Character distribution analyzer (mDistributionAnalyser) and 2-Char sequence
analyzer (mContextAnalyser) for statistic sampling. "GetConfidence" call
will let its caller know the likelihood of input charset being of this
encoding.</font>
<p><font size=-1>Inside "HandleData" method each time after a batch of
text has been processed, shortcut judgement is performed. If the prober
receives enough data and reaches certain confidence level, it will set
its state to be "eFoundIt" and notify its caller an immediate sure answer.</font>
<p><font size=-1>For encoding like ISO_2022 and HZ, since the embedded
state machine can do almost a perfect job along, no other statistic sampling
is done.</font>
<p><i><font size=-1>Big5Freq.tab</font></i>
<p><i><font size=-1>EUCKRFreq.tab</font></i>
<p><i><font size=-1>EUCTWFreq.tab</font></i>
<p><i><font size=-1>GB2312Freq.tab</font></i>
<p><i><font size=-1>JISFreq.tab</font></i>
<p><i><font size=-1>Those files defined the frequency table (Character
to frequency order mapping) for each language. Since Big5 and EUC-TW are
not basing on the same charset standard like EUC-JP and SJIS do, 2 tables
is defined.</font></i>
<p><i><font size=-1>CharDistribution.h</font></i>
<p><i><font size=-1>CharDistribution.cpp</font></i>
<p><i><font size=-1>Implementation for Character distribution analyzer.</font></i>
<p><i><font size=-1>nsPkgInt.h</font></i>
<p><i><font size=-1>nsCodingStateMachine.h</font></i>
<p><i><font size=-1>Those are bases of state machine implementation.</font></i>
<p><i><font size=-1>nsEscSM.cpp</font></i>
<p><i><font size=-1>State machine for ISO-2022XX and HZ.</font></i>
<p><i><font size=-1>nsMBCSSM.cpp</font></i>
<p><i><font size=-1>State machines for Big5, EUC-JP, EUC-KR, EUC-TW, GB2312,
SJIS, and UTF8.</font></i>
<p><i><font size=-1>JpCntx.h</font></i>
<p><i><font size=-1>JpCntx.cpp</font></i>
<p><i><font size=-1>Japanese hiragana sequence analyzer.</font></i>
<p><i><font size=-1>nsBig5Prober.h</font></i>
<p><i><font size=-1>nsBig5Prober.cpp</font></i>
<p><i><font size=-1>nsEUCKRProber.h</font></i>
<p><i><font size=-1>nsEUCKRProber.cpp</font></i>
<p><i><font size=-1>nsEUCJPProber.h</font></i>
<p><i><font size=-1>nsEUCJPProber.cpp</font></i>
<p><i><font size=-1>nsEUCTWProber.h</font></i>
<p><i><font size=-1>nsEUCTWProber.cpp</font></i>
<p><i><font size=-1>nsSJISProber.h</font></i>
<p><i><font size=-1>nsSJISProber.cpp</font></i>
<p><i><font size=-1>nsGB2312Prober.h</font></i>
<p><i><font size=-1>nsGB2312Prober.cpp</font></i>
<p><i><font size=-1>nsUTF8Prober.h</font></i>
<p><i><font size=-1>nsUTF8Prober.cpp</font></i>
<p><i><font size=-1>Charset Prober classes definition and implementation
for each encoding. Each prober has an embedded state machine and a character
distribution analyzer except UTF8, which state machine is good enough.</font></i>
<p><i><font size=-1>nsMBCSProber.h</font></i>
<p><i><font size=-1>nsMBCSProber.cpp</font></i>
<p><i><font size=-1>This is a wrapper of all the MBCS probers. I was expecting
to put some high level logic which base on multiple encoding knowledge
to appears here in the very beginning. That might still be needed in future.</font></i>
<br>&nbsp;
<br>&nbsp;
<p><font face="Arial">How single-byte encoding charset prober works</font>
<p><font size=-1>For each encoding, a table is used to map a character
to an encoding independent identification number. Those identification
numbers in fact come from charactersy枅requency order but with some adjustment.
For each language, a 2-D matrix is defined as language model. If cell &lt;x,
y> is 0, it means sequence &lt;character(x), character(y)> is a rarely
used sequence in this language, with character(x) representing the character
whose identification number is x. The 2-D matrix only defines sequence
of a subset of all the characters. For characters whose identification
number is out of this range, those characters are ignored. Since some of
the sequences, like ascii-to-ascii sequences, have no relation with the
language we try to verify, and those sequences should not be counted. In
current implementation, a sequence will be counted if both characters are
8-bits ones. In some situations, one 8-bits character sequence is expected
to be counted.</font>
<p><i><font size=-1>LangCyrillicModel.cpp : these files defined a mapping
table for each encoding and a 2-D matrix for all Cyrillic languages. A
"SequenceModel" structure is also defined for each encoding. This structure
will be used to initialize a single-byte character prober class. All Cyrillic
encodings are sharing the same prober class implementation.</font></i>
<p><i><font size=-1>nsSBCharSetProber.h</font></i>
<p><i><font size=-1>nsSBCharSetProber.cpp : These 2 files defined and implemented
single-byte charset prober.</font></i>





<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="http://mozilla.jp/">ホーム</a></li>
<li><a href="/security/">セキュリティ情報</a></li>
<li><a href="http://mozilla.jp/legal/privacy/">個人情報保護方針</a></li>
<li><a href="http://mozilla.jp/about/contact">お問い合わせ</a></li>
</ul>
<p class="copyright">&copy; 2004-2008 Mozilla Japan, Mozilla Foundation and Mozilla Corporation<br>Mozilla Japan は <a href="http://www.mozilla.org/">Mozilla Foundation</a> と <a href="http://www.mozilla.com/en-US/">Mozilla Corporation</a> の公式アフィリエイトです。</p>
<p><span><a href="http://www.mozilla.org/projects/intl/ChardetInterface.htm">英語版</a> 2002/11/20</span> - <span>和訳版 2008/01/31</span> - <span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/projects/intl/ChardetInterface.htm">英語版更新履歴</a></span></p>
<p>この文書は翻訳で、原文は <a href="http://www.mozilla.org/">mozilla.org</a> において英語で管理・公開されています。<br>この翻訳文書は、利用者の利便のために <a href="/jp/td/">Mozilla Japan 翻訳部門</a> により提供されています。<br>翻訳文書についてのコメントは <a href="http://forums.firehacks.org/trans/viewforum.php?f=2">mozilla.org 日本語版について</a> までお寄せください。</p>
</div>

</div>
</body>
</html>
